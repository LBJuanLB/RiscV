$date
	Wed Nov 01 22:22:36 2023
$end
$version
	Icarus Verilog
$end
$timescale
	1ns
$end
$scope module CPU_TB $end
$var reg 1 ! clk $end
$var reg 1 " reset $end
$var reg 1 # rst $end
$scope module cpu $end
$var wire 1 ! clk $end
$var wire 1 " reset $end
$var wire 1 # rst $end
$var wire 1 $ we $end
$var wire 32 % sum_out [31:0] $end
$var wire 1 & store $end
$var wire 3 ' salida_funct3 [2:0] $end
$var wire 32 ( result [31:0] $end
$var wire 32 ) pc_out [31:0] $end
$var wire 32 * pc_in [31:0] $end
$var wire 32 + operand2 [31:0] $end
$var wire 32 , operand1 [31:0] $end
$var wire 32 - load_data [31:0] $end
$var wire 32 . instruction [31:0] $end
$var wire 32 / imm32 [31:0] $end
$var wire 3 0 funct_imm [2:0] $end
$var wire 32 1 data2 [31:0] $end
$var wire 32 2 data1 [31:0] $end
$var wire 32 3 data [31:0] $end
$var wire 2 4 controlRF [1:0] $end
$var wire 1 5 controlOp1 $end
$var wire 1 6 controlALU $end
$var wire 3 7 Type_dm [2:0] $end
$var wire 1 8 Type_alu_dm $end
$var wire 1 9 NextPCSrc $end
$var wire 5 : BrOp [4:0] $end
$var parameter 32 ; TAM $end
$var reg 3 < funct3 [2:0] $end
$var reg 7 = funct7 [6:0] $end
$var reg 25 > immediate [24:0] $end
$var reg 7 ? opcode [6:0] $end
$var reg 5 @ rd [4:0] $end
$var reg 1 A read $end
$var reg 5 B rs1 [4:0] $end
$var reg 5 C rs2 [4:0] $end
$scope module alu $end
$var wire 1 D clk $end
$var wire 32 E operand2 [31:0] $end
$var wire 32 F operand1 [31:0] $end
$var wire 3 G funct3_alu [2:0] $end
$var wire 1 8 Type_alu $end
$var reg 1 H bit_significativo $end
$var reg 32 I conteo [31:0] $end
$var reg 32 J result [31:0] $end
$upscope $end
$scope module branch $end
$var wire 32 K RUrs2 [31:0] $end
$var wire 32 L RUrs1 [31:0] $end
$var wire 5 M BrOp [4:0] $end
$var reg 1 9 NextPCSrc $end
$upscope $end
$scope module cu $end
$var wire 3 N funct3 [2:0] $end
$var wire 7 O funct7 [6:0] $end
$var wire 7 P opcode [6:0] $end
$var reg 5 Q BrOp [4:0] $end
$var reg 1 8 Type_alu $end
$var reg 3 R Type_dm [2:0] $end
$var reg 1 6 controlALU $end
$var reg 1 5 controlOp1 $end
$var reg 2 S controlRF [1:0] $end
$var reg 3 T funct_imm [2:0] $end
$var reg 3 U salida_funct3 [2:0] $end
$var reg 1 & store $end
$var reg 1 $ we $end
$upscope $end
$scope module dm $end
$var wire 3 V Type [2:0] $end
$var wire 1 ! clk $end
$var wire 1 & store $end
$var wire 32 W store_data [31:0] $end
$var wire 32 X offset [31:0] $end
$var wire 32 Y direccion [31:0] $end
$var wire 32 Z address [31:0] $end
$var parameter 32 [ TAM $end
$var reg 32 \ count [31:0] $end
$var reg 32 ] data [31:0] $end
$var reg 32 ^ load_data [31:0] $end
$upscope $end
$scope module im $end
$var wire 32 _ pc [31:0] $end
$var parameter 32 ` TAM $end
$var reg 32 a instruction [31:0] $end
$upscope $end
$scope module imm $end
$var wire 3 b funct [2:0] $end
$var wire 25 c immediate [24:0] $end
$var reg 32 d imm32 [31:0] $end
$upscope $end
$scope module mux1 $end
$var wire 1 6 control $end
$var wire 32 e entrada2 [31:0] $end
$var wire 32 f salida [31:0] $end
$var wire 32 g entrada1 [31:0] $end
$upscope $end
$scope module mux2 $end
$var wire 2 h control [1:0] $end
$var wire 32 i entrada1 [31:0] $end
$var wire 32 j entrada2 [31:0] $end
$var wire 32 k salida [31:0] $end
$var wire 32 l entrada3 [31:0] $end
$upscope $end
$scope module mux3 $end
$var wire 1 9 control $end
$var wire 32 m entrada2 [31:0] $end
$var wire 32 n salida [31:0] $end
$var wire 32 o entrada1 [31:0] $end
$upscope $end
$scope module mux4 $end
$var wire 1 5 control $end
$var wire 32 p salida [31:0] $end
$var wire 32 q entrada2 [31:0] $end
$var wire 32 r entrada1 [31:0] $end
$upscope $end
$scope module pc $end
$var wire 1 ! clk $end
$var wire 32 s pc_in [31:0] $end
$var wire 1 " reset $end
$var reg 32 t pc_out [31:0] $end
$upscope $end
$scope module rf $end
$var wire 1 $ WriteEnable $end
$var wire 1 ! clk $end
$var wire 32 u data [31:0] $end
$var wire 5 v rd [4:0] $end
$var wire 5 w rs1 [4:0] $end
$var wire 5 x rs2 [4:0] $end
$var wire 1 # rst $end
$var reg 32 y data1 [31:0] $end
$var reg 32 z data2 [31:0] $end
$var reg 32 { i [31:0] $end
$upscope $end
$scope module sumador $end
$var wire 32 | pc [31:0] $end
$var reg 32 } sum_out [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b1111111111 `
b1111111111 [
b1111111111 ;
$end
#0
$dumpvars
bx }
bx |
bx {
bx z
bx y
bx x
bx w
bx v
bx u
bx t
bx s
bx r
bx q
bx p
bx o
bx n
bx m
bx l
bx k
bx j
bx i
bx h
bx g
bx f
bx e
bx d
bx c
bx b
bx a
bx _
bx ^
bx ]
bx \
bx Z
bx Y
bx X
bx W
bx V
bx U
bx T
bx S
bx R
bx Q
bx P
bx O
bx N
bx M
bx L
bx K
bx J
bx I
xH
bx G
bx F
bx E
zD
bx C
bx B
1A
bx @
bx ?
bx >
bx =
bx <
bx :
x9
x8
bx 7
x6
x5
bx 4
bx 3
bx 2
bx 1
bx 0
bx /
bx .
bx -
bx ,
bx +
bx *
bx )
bx (
bx '
x&
bx %
x$
1#
x"
1!
$end
#5
0!
#10
1!
1"
0#
#15
b10011100010000000110010111 .
b10011100010000000110010111 a
b100 %
b100 l
b100 o
b100 }
b0 )
b0 _
b0 q
b0 t
b0 |
0!
#20
b0 1
b0 K
b0 W
b0 g
b0 z
b1001110001000000011111010000000 Z
b111110100 2
b111110100 L
b111110100 Y
b111110100 r
b111110100 y
b10011100010000000000000000 3
b10011100010000000000000000 k
b10011100010000000000000000 u
b10011100010000000000000000 (
b10011100010000000000000000 J
b10011100010000000000000000 j
b10011100010000000000000000 m
b100 *
b100 n
b100 s
b0 ,
b0 F
b0 p
b10011100010000000000000000 +
b10011100010000000000000000 E
b10011100010000000000000000 f
09
b10011100010000000000000000 /
b10011100010000000000000000 X
b10011100010000000000000000 d
b10011100010000000000000000 e
15
b1 4
b1 S
b1 h
08
16
b0 '
b0 G
b0 U
1$
b0 :
b0 M
b0 Q
b11 0
b11 T
b11 b
0&
b1001110001000000011 >
b1001110001000000011 c
b111 C
b111 x
b10 B
b10 w
b11 @
b11 v
b1 =
b1 O
b0 <
b0 N
b10111 ?
b10111 P
1!
0"
#25
b0 .
b0 a
b10011100010000000000000100 3
b10011100010000000000000100 k
b10011100010000000000000100 u
b10011100010000000000000100 (
b10011100010000000000000100 J
b10011100010000000000000100 j
b10011100010000000000000100 m
b100 ,
b100 F
b100 p
b1000 *
b1000 n
b1000 s
b1000 %
b1000 l
b1000 o
b1000 }
b100 )
b100 _
b100 q
b100 t
b100 |
0!
#30
b0 2
b0 L
b0 Y
b0 r
b0 y
b100 3
b100 k
b100 u
b100 (
b100 J
b100 j
b100 m
b0 +
b0 E
b0 f
b0 Z
b0 /
b0 X
b0 d
b0 e
b100000 {
b0 >
b0 c
b0 C
b0 x
b0 B
b0 w
b0 @
b0 v
b0 =
b0 O
b0 ?
b0 P
1!
#35
bx .
bx a
b1000 3
b1000 k
b1000 u
b1000 (
b1000 J
b1000 j
b1000 m
b1000 ,
b1000 F
b1000 p
b1100 *
b1100 n
b1100 s
b1100 %
b1100 l
b1100 o
b1100 }
b1000 )
b1000 _
b1000 q
b1000 t
b1000 |
0!
