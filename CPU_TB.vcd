$date
	Wed Nov 01 22:57:18 2023
$end
$version
	Icarus Verilog
$end
$timescale
	1ns
$end
$scope module CPU_TB $end
$var reg 1 ! clk $end
$var reg 1 " reset $end
$var reg 1 # rst $end
$scope module cpu $end
$var wire 1 ! clk $end
$var wire 1 " reset $end
$var wire 1 # rst $end
$var wire 1 $ we $end
$var wire 32 % sum_out [31:0] $end
$var wire 1 & store $end
$var wire 3 ' salida_funct3 [2:0] $end
$var wire 32 ( result [31:0] $end
$var wire 32 ) pc_out [31:0] $end
$var wire 32 * pc_in [31:0] $end
$var wire 32 + operand2 [31:0] $end
$var wire 32 , operand1 [31:0] $end
$var wire 32 - load_data [31:0] $end
$var wire 32 . instruction [31:0] $end
$var wire 32 / imm32 [31:0] $end
$var wire 3 0 funct_imm [2:0] $end
$var wire 32 1 data2 [31:0] $end
$var wire 32 2 data1 [31:0] $end
$var wire 32 3 data [31:0] $end
$var wire 2 4 controlRF [1:0] $end
$var wire 1 5 controlOp1 $end
$var wire 1 6 controlALU $end
$var wire 3 7 Type_dm [2:0] $end
$var wire 1 8 Type_alu_dm $end
$var wire 1 9 NextPCSrc $end
$var wire 5 : BrOp [4:0] $end
$var parameter 32 ; TAM $end
$var reg 3 < funct3 [2:0] $end
$var reg 7 = funct7 [6:0] $end
$var reg 25 > immediate [24:0] $end
$var reg 7 ? opcode [6:0] $end
$var reg 5 @ rd [4:0] $end
$var reg 1 A read $end
$var reg 5 B rs1 [4:0] $end
$var reg 5 C rs2 [4:0] $end
$scope module alu $end
$var wire 1 D clk $end
$var wire 32 E operand2 [31:0] $end
$var wire 32 F operand1 [31:0] $end
$var wire 3 G funct3_alu [2:0] $end
$var wire 1 8 Type_alu $end
$var reg 1 H bit_significativo $end
$var reg 32 I conteo [31:0] $end
$var reg 32 J result [31:0] $end
$upscope $end
$scope module branch $end
$var wire 32 K RUrs2 [31:0] $end
$var wire 32 L RUrs1 [31:0] $end
$var wire 5 M BrOp [4:0] $end
$var reg 1 9 NextPCSrc $end
$upscope $end
$scope module cu $end
$var wire 3 N funct3 [2:0] $end
$var wire 7 O funct7 [6:0] $end
$var wire 7 P opcode [6:0] $end
$var reg 5 Q BrOp [4:0] $end
$var reg 1 8 Type_alu $end
$var reg 3 R Type_dm [2:0] $end
$var reg 1 6 controlALU $end
$var reg 1 5 controlOp1 $end
$var reg 2 S controlRF [1:0] $end
$var reg 3 T funct_imm [2:0] $end
$var reg 3 U salida_funct3 [2:0] $end
$var reg 1 & store $end
$var reg 1 $ we $end
$upscope $end
$scope module dm $end
$var wire 3 V Type [2:0] $end
$var wire 1 ! clk $end
$var wire 1 & store $end
$var wire 32 W store_data [31:0] $end
$var wire 32 X offset [31:0] $end
$var wire 32 Y direccion [31:0] $end
$var wire 32 Z address [31:0] $end
$var parameter 32 [ TAM $end
$var reg 32 \ count [31:0] $end
$var reg 32 ] data [31:0] $end
$var reg 32 ^ load_data [31:0] $end
$upscope $end
$scope module im $end
$var wire 32 _ pc [31:0] $end
$var parameter 32 ` TAM $end
$var reg 32 a instruction [31:0] $end
$upscope $end
$scope module imm $end
$var wire 3 b funct [2:0] $end
$var wire 25 c immediate [24:0] $end
$var reg 32 d imm32 [31:0] $end
$upscope $end
$scope module mux1 $end
$var wire 1 6 control $end
$var wire 32 e entrada2 [31:0] $end
$var wire 32 f entrada1 [31:0] $end
$var reg 32 g salida [31:0] $end
$upscope $end
$scope module mux2 $end
$var wire 2 h control [1:0] $end
$var wire 32 i entrada1 [31:0] $end
$var wire 32 j entrada2 [31:0] $end
$var wire 32 k salida [31:0] $end
$var wire 32 l entrada3 [31:0] $end
$upscope $end
$scope module mux3 $end
$var wire 1 9 control $end
$var wire 32 m entrada2 [31:0] $end
$var wire 32 n entrada1 [31:0] $end
$var reg 32 o salida [31:0] $end
$upscope $end
$scope module mux4 $end
$var wire 1 5 control $end
$var wire 32 p entrada2 [31:0] $end
$var wire 32 q entrada1 [31:0] $end
$var reg 32 r salida [31:0] $end
$upscope $end
$scope module pc $end
$var wire 1 ! clk $end
$var wire 32 s pc_in [31:0] $end
$var wire 1 " reset $end
$var reg 32 t pc_out [31:0] $end
$upscope $end
$scope module rf $end
$var wire 1 $ WriteEnable $end
$var wire 1 ! clk $end
$var wire 32 u data [31:0] $end
$var wire 5 v rd [4:0] $end
$var wire 5 w rs1 [4:0] $end
$var wire 5 x rs2 [4:0] $end
$var wire 1 # rst $end
$var reg 32 y data1 [31:0] $end
$var reg 32 z data2 [31:0] $end
$var reg 32 { i [31:0] $end
$upscope $end
$scope module sumador $end
$var wire 32 | pc [31:0] $end
$var reg 32 } sum_out [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b1111111111 `
b1111111111 [
b1111111111 ;
$end
#0
$dumpvars
bx }
bx |
bx {
bx z
bx y
bx x
bx w
bx v
bx u
bx t
bx s
bx r
bx q
bx p
bx o
bx n
bx m
bx l
bx k
bx j
bx i
bx h
bx g
bx f
bx e
bx d
bx c
bx b
bx a
bx _
bx ^
bx ]
bx \
bx Z
bx Y
bx X
bx W
bx V
bx U
bx T
bx S
bx R
bx Q
bx P
bx O
bx N
bx M
bx L
bx K
bx J
bx I
xH
bx G
bx F
bx E
zD
bx C
bx B
1A
bx @
bx ?
bx >
bx =
bx <
bx :
x9
x8
bx 7
x6
x5
bx 4
bx 3
bx 2
bx 1
bx 0
bx /
bx .
bx -
bx ,
bx +
bx *
bx )
bx (
bx '
x&
bx %
x$
1#
x"
1!
$end
#5
0!
#10
1!
1"
0#
#15
b1010000000000000100010011 .
b1010000000000000100010011 a
b0 *
b0 o
b0 s
b100 %
b100 l
b100 n
b100 }
b0 ,
b0 F
b0 r
b0 )
b0 _
b0 p
b0 t
b0 |
0!
#20
b10100 3
b10100 k
b10100 u
b10100 (
b10100 J
b10100 j
b10100 m
b0 1
b0 K
b0 W
b0 f
b0 z
b1010000000 Z
b0 2
b0 L
b0 Y
b0 q
b0 y
b100 *
b100 o
b100 s
b0 ,
b0 F
b0 r
b10100 +
b10100 E
b10100 g
09
b10100 /
b10100 X
b10100 d
b10100 e
08
b0 '
b0 G
b0 U
b0 0
b0 T
b0 b
b1 4
b1 S
b1 h
1$
05
16
b0 :
b0 M
b0 Q
0&
b101000000000000010 >
b101000000000000010 c
b10100 C
b10100 x
b0 B
b0 w
b10 @
b10 v
b0 =
b0 O
b0 <
b0 N
b10011 ?
b10011 P
1!
0"
#25
b1010000000000001110010011 .
b1010000000000001110010011 a
b1000 *
b1000 o
b1000 s
b1000 %
b1000 l
b1000 n
b1000 }
b100 )
b100 _
b100 p
b100 t
b100 |
0!
#30
b101000000000000111 >
b101000000000000111 c
b111 @
b111 v
1!
#35
b10011100010000000110110111 .
b10011100010000000110110111 a
b1100 *
b1100 o
b1100 s
b1100 %
b1100 l
b1100 n
b1100 }
b1000 )
b1000 _
b1000 p
b1000 t
b1000 |
0!
#40
b10100 1
b10100 K
b10100 W
b10100 f
b10100 z
b10100 2
b10100 L
b10100 Y
b10100 q
b10100 y
b10011100010000000000000000 3
b10011100010000000000000000 k
b10011100010000000000000000 u
b10011100010000000000000000 (
b10011100010000000000000000 J
b10011100010000000000000000 j
b10011100010000000000000000 m
b10011100010000000000000000 +
b10011100010000000000000000 E
b10011100010000000000000000 g
b1001110001000000000001010000000 Z
b10011100010000000000000000 /
b10011100010000000000000000 X
b10011100010000000000000000 d
b10011100010000000000000000 e
x5
b11 0
b11 T
b11 b
b1001110001000000011 >
b1001110001000000011 c
b111 C
b111 x
b10 B
b10 w
b11 @
b11 v
b1 =
b1 O
b110111 ?
b110111 P
1!
#45
b10000010100001010110011 .
b10000010100001010110011 a
b10000 *
b10000 o
b10000 s
b10000 %
b10000 l
b10000 n
b10000 }
b1100 )
b1100 _
b1100 p
b1100 t
b1100 |
0!
#50
b0 1
b0 K
b0 W
b0 f
b0 z
b10100 3
b10100 k
b10100 u
b10100 (
b10100 J
b10100 j
b10100 m
b10100 ,
b10100 F
b10100 r
b0 +
b0 E
b0 g
b1000001010000000001010000000 Z
b10000010100000000000000 /
b10000010100000000000000 X
b10000010100000000000000 d
b10000010100000000000000 e
b100 '
b100 G
b100 U
05
06
b1000001010000101 >
b1000001010000101 c
b100 C
b100 x
b101 @
b101 v
b0 =
b0 O
b100 <
b100 N
b110011 ?
b110011 P
1!
#55
b0 .
b0 a
b10100 *
b10100 o
b10100 s
b10100 %
b10100 l
b10100 n
b10100 }
b10000 )
b10000 _
b10000 p
b10000 t
b10000 |
0!
#60
b0 3
b0 k
b0 u
b0 (
b0 J
b0 j
b0 m
b0 ,
b0 F
b0 r
b0 2
b0 L
b0 Y
b0 q
b0 y
b0 Z
b0 /
b0 X
b0 d
b0 e
b100000 {
b0 >
b0 c
b0 C
b0 x
b0 B
b0 w
b0 @
b0 v
b0 <
b0 N
b0 ?
b0 P
1!
#65
bx .
bx a
b11000 *
b11000 o
b11000 s
b11000 %
b11000 l
b11000 n
b11000 }
b10100 )
b10100 _
b10100 p
b10100 t
b10100 |
0!
